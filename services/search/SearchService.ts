import { Lead, SearchConfigState } from '../../lib/types';
import { deduplicationService } from '../deduplication/DeduplicationService';

export type LogCallback = (message: string) => void;
export type ResultCallback = (leads: Lead[]) => void;

// Apify Actor IDs
// Apify Actor IDs
const GOOGLE_MAPS_SCRAPER = 'nwua9Gu5YrADL7ZDj';
const CONTACT_SCRAPER = 'vdrmO1lXCkhbPjE9j';
const GOOGLE_SEARCH_SCRAPER = 'nFJndFXA5zjCTuudP'; // ID for apify/google-search-scraper

export class SearchService {
    private isRunning = false;
    private apiKey: string = '';
    private userId: string | null = null; // For deduplication

    public stop() {
        this.isRunning = false;
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // SMART QUERY INTERPRETER
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    private async interpretQuery(userQuery: string, platform: 'gmail' | 'linkedin'): Promise<{
        searchQuery: string;
        industry: string;
        targetRoles: string[];
        location: string;
    }> {
        try {
            console.log('[INTERPRET] ğŸ“¡ Llamando /api/openai...');
            const controller = new AbortController();
            const timeoutId = setTimeout(() => controller.abort(), 15000); // 15 sec timeout

            // Llamar a nuestra API route privada en lugar de OpenAI directamente
            const response = await fetch('/api/openai', {
                method: 'POST',
                signal: controller.signal,
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    model: 'gpt-4o-mini',
                    messages: [
                        {
                            role: 'system',
                            content: `Eres un experto en prospecciÃ³n B2B. Interpreta la bÃºsqueda para encontrar DUEÃ‘OS y DECISORES.
Responde SOLO con JSON:
{
  "searchQuery": "tÃ©rmino optimizado",
  "industry": "sector detectado",
  "targetRoles": ["CEO", "Fundador", etc],
  "location": "ubicaciÃ³n o EspaÃ±a"
}`
                        },
                        { role: 'user', content: `BÃºsqueda: "${userQuery}"` }
                    ],
                    temperature: 0.3,
                    max_tokens: 150
                })
            });
            clearTimeout(timeoutId);

            if (!response.ok) {
                const err = await response.text();
                console.error(`[INTERPRET] HTTP ${response.status}:`, err.substring(0, 300));
                throw new Error(`HTTP ${response.status}`);
            }

            const data = await response.json();
            const match = data.choices?.[0]?.message?.content?.match(/\{[\s\S]*\}/);
            if (match) {
                console.log('[INTERPRET] âœ… Query interpretada exitosamente');
                return JSON.parse(match[0]);
            }
        } catch (e: any) {
            console.error('[INTERPRET] Error:', e.message);
        }

        console.log('[INTERPRET] âš ï¸ Fallback: usando query as-is');
        return { searchQuery: userQuery, industry: userQuery, targetRoles: ['CEO', 'Fundador', 'Propietario'], location: 'EspaÃ±a' };
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // ADVANCED FILTERS PROCESSOR
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    private buildQueryWithAdvancedFilters(baseQuery: string, filters?: any): string {
        if (!filters || !Object.keys(filters).length) {
            return baseQuery;
        }

        const parts = [baseQuery];

        // Add locations to query
        if (filters.locations && filters.locations.length > 0) {
            parts.push(`(${filters.locations.map((loc: string) => `"${loc}"`).join(' OR ')})`);
        }

        // Add job titles to query
        if (filters.jobTitles && filters.jobTitles.length > 0) {
            parts.push(`(${filters.jobTitles.map((job: string) => `"${job}"`).join(' OR ')})`);
        }

        // Add industries to query
        if (filters.industries && filters.industries.length > 0) {
            parts.push(`(${filters.industries.map((ind: string) => `"${ind}"`).join(' OR ')})`);
        }

        // Add keywords to query
        if (filters.keywords && filters.keywords.length > 0) {
            parts.push(`(${filters.keywords.map((key: string) => `"${key}"`).join(' OR ')})`);
        }

        return parts.join(' AND ');
    }

    /**
     * Check if a lead matches advanced filter criteria
     */
    private leadMatchesFilters(lead: Lead, filters?: any): boolean {
        if (!filters) return true;

        try {
            // Check locations
            if (filters.locations && filters.locations.length > 0) {
                const leadLocation = (lead.location || '').toLowerCase();
                const matchesLocation = filters.locations.some((loc: string) =>
                    leadLocation.includes(loc.toLowerCase())
                );
                if (!matchesLocation) return false;
            }

            // Check company sizes (if available in lead data)
            if (filters.companySizes && filters.companySizes.length > 0) {
                // Company size usually comes from summary/analysis
                const summary = (lead.aiAnalysis?.summary || '').toLowerCase();
                const matchesSize = filters.companySizes.some((size: string) => {
                    if (size === 'startup') return summary.includes('1-50') || summary.includes('pequeÃ±a');
                    if (size === 'small') return summary.includes('1-100') || summary.includes('pequeÃ±a');
                    if (size === 'medium') return summary.includes('100-1000') || summary.includes('mediana');
                    if (size === 'large') return summary.includes('1000+') || summary.includes('grande');
                    return summary.includes(size);
                });
                if (!matchesSize && filters.companySizes.length > 0) return false;
            }

            return true;
        } catch (e) {
            return true; // If filtering fails, keep the lead
        }
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // DEEP RESEARCH - Google Search for company/owner info
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    private async deepResearchLead(lead: Lead, onLog: LogCallback): Promise<string> {
        if (!this.isRunning) return '';

        const searchQueries = [];

        // Research company
        if (lead.companyName && lead.companyName !== 'Sin Nombre') {
            searchQueries.push(`"${lead.companyName}" empresa valores misiÃ³n`);
        }

        // Research owner if we have a name
        if (lead.decisionMaker?.name) {
            searchQueries.push(`"${lead.decisionMaker.name}" ${lead.companyName} entrevista`);
            searchQueries.push(`"${lead.decisionMaker.name}" linkedin`);
        }

        // Research from website
        if (lead.website) {
            searchQueries.push(`site:${lead.website} "sobre nosotros" OR "quiÃ©nes somos" OR "about"`);
        }

        if (searchQueries.length === 0) return '';

        try {
            const searchInput = {
                queries: searchQueries.join('\n'),
                maxPagesPerQuery: 1,
                resultsPerPage: 5,
                languageCode: 'es',
                countryCode: 'es',
            };

            const results = await this.callApifyActor(GOOGLE_SEARCH_SCRAPER, searchInput, (msg) => { }); // Silent

            let researchData = '';
            for (const result of results) {
                if (result.organicResults) {
                    for (const organic of result.organicResults.slice(0, 3)) {
                        researchData += `\n- ${organic.title}: ${organic.description || ''}`;
                    }
                }
            }

            return researchData;
        } catch (e) {
            return '';
        }
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // ULTRA-COMPLETE AI ANALYSIS - Psychological + Business + Bottleneck
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    private async generateUltraAnalysis(lead: Lead, researchData: string): Promise<{
        fullAnalysis: string;
        psychologicalProfile: string;
        businessMoment: string;
        salesAngle: string;
        personalizedMessage: string;
        bottleneck: string;
    }> {
        // Siempre intentar llamar /api/openai (no depender de this.openaiKey)
        const context = `
â•â•â• DATOS DEL LEAD â•â•â•
Empresa: ${lead.companyName}
Web: ${lead.website || 'No disponible'}
UbicaciÃ³n: ${lead.location || 'EspaÃ±a'}
Decisor: ${lead.decisionMaker?.name || 'No identificado'}
Cargo: ${lead.decisionMaker?.role || 'Propietario'}
Email: ${lead.decisionMaker?.email || 'No disponible'}
LinkedIn: ${lead.decisionMaker?.linkedin || 'No disponible'}
Resumen inicial: ${lead.aiAnalysis?.summary || ''}

â•â•â• INVESTIGACIÃ“N ADICIONAL â•â•â•
${researchData || 'Sin datos adicionales'}
        `.trim();

        const MAX_RETRIES = 2;
        for (let attempt = 1; attempt <= MAX_RETRIES; attempt++) {
            try {
                const response = await fetch('/api/openai', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        model: 'gpt-4o-mini',
                        messages: [
                            {
                                role: 'system',
                                content: `Eres un GENIO del anÃ¡lisis de negocios y psicologÃ­a empresarial. Tu trabajo es hacer el anÃ¡lisis MÃS COMPLETO posible de cada lead para ventas B2B.

SI HAY DATOS DE "ACTIVIDAD RECIENTE (Posts)":
- Analiza su estilo de escritura (Directo, Reflexivo, TÃ©cnico, Vendedor).
- Deduce sus valores y quÃ© temas le obsesionan ahora mismo.
- Ãšsalo para personalizar el mensaje al mÃ¡ximo.

DEBES generar exactamente este JSON (sin markdown, solo JSON puro):
{
  "psychologicalProfile": "Describe su perfil en 2 frases (Ej: 'Visionario y directo. Valora la innovaciÃ³n...')",
  "businessMoment": "Deduce en quÃ© fase estÃ¡ la empresa (Ej: 'ExpansiÃ³n agresiva', 'ConsolidaciÃ³n', 'Buscando eficiencia')",
  "salesAngle": "El argumento ÃšNICO para venderle a ESTA persona hoy.",
  "bottleneck": "Una frase BRUTAL y especÃ­fica sobre su mayor freno o cuello de botella detectado.",
  "personalizedMessage": "Mensaje de 100 palabras. Tono 'Coffee Chat' profesional. MENCIONA SU ÃšLTIMO POST O ACTIVIDAD si existe."
}

IMPORTANTE: Responde SOLO con JSON vÃ¡lido.`
                            },
                            {
                                role: 'user',
                                content: `Analiza este lead (Intento ${attempt}):\n\n${context}`
                            }
                        ],
                        temperature: 0.7,
                        max_tokens: 1000
                    })
                });

                if (!response.ok) throw new Error(`HTTP ${response.status}`);

                const data = await response.json();
                const content = data.choices?.[0]?.message?.content || '';
                const jsonMatch = content.match(/\{[\s\S]*\}/);

                if (jsonMatch) {
                    const parsed = JSON.parse(jsonMatch[0]);
                    return {
                        fullAnalysis: `ğŸ§  PERFIL: ${parsed.psychologicalProfile}\nğŸ¢ MOMENTO: ${parsed.businessMoment}\nğŸ’¡ ÃNGULO: ${parsed.salesAngle}`,
                        psychologicalProfile: parsed.psychologicalProfile || 'No detectado',
                        businessMoment: parsed.businessMoment || 'No detectado',
                        salesAngle: parsed.salesAngle || 'GenÃ©rico',
                        personalizedMessage: parsed.personalizedMessage || `Hola ${lead.decisionMaker?.name || 'equipo'}, me gustarÃ­a contactar con vosotros.`,
                        bottleneck: parsed.bottleneck || 'Oportunidad de mejora detectada'
                    };
                }
            } catch (e) {
                console.error(`Attempt ${attempt} failed:`, e);
                if (attempt === MAX_RETRIES) break;
                await new Promise(r => setTimeout(r, 1000 * attempt));
            }
        }

        // Fallback genÃ©rico decente (sin "Sin API Key")
        return {
            fullAnalysis: `${lead.companyName}: Agencia de bienes raÃ­ces activa en ${lead.location || 'EspaÃ±a'}. Decisor influenciado por eficiencia operativa.`,
            psychologicalProfile: `${lead.decisionMaker?.role || 'Propietario'} de inmobiliaria. Probablemente valora sistemas automatizados.`,
            businessMoment: 'ExpansiÃ³n o consolidaciÃ³n',
            salesAngle: 'AutomatizaciÃ³n de procesos y escalabilidad',
            personalizedMessage: `Hola ${lead.decisionMaker?.name || 'equipo'}, he visto que gestionÃ¡is ${lead.companyName}. Tengo una oportunidad para automatizar vuestros procesos.`,
            bottleneck: 'GestiÃ³n manual de leads y contactos limitando el crecimiento'
        };
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // GENERATE TWO MESSAGES FOR MARCOS (Message A & B)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    private async generateOneMessage(lead: Lead): Promise<{
        messageA: string;
    }> {
        console.log('[MESSAGE] Generando 1 mensaje (solo producto)...');

        try {
            console.log('[MESSAGE] ğŸ“¡ Llamando /api/openai...');

            const controller = new AbortController();
            const timeoutId = setTimeout(() => {
                controller.abort();
                console.error('[MESSAGE] TIMEOUT (15s)');
            }, 15000);

            const response = await fetch('/api/openai', {
                method: 'POST',
                signal: controller.signal,
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    model: 'gpt-4o-mini',
                    messages: [
                        {
                            role: 'system',
                            content: `Eres un experto en mensajes de LinkedIn para inmobiliarias espaÃ±olas. 
Tu misiÃ³n: Generar UN ÃšNICO icebreaker corto (<25 palabras) enfocado en AUTOMATIZACIÃ“N de procesos.

El mensaje debe ser:
- Directo y profesional
- "Read-able" en 5 segundos
- Centrado en eficiencia operativa y crecimiento

Responde SOLO con JSON: {"messageA": "..."}`
                        },
                        {
                            role: 'user',
                            content: `Empresa: ${lead.companyName}
Responsable: ${lead.decisionMaker?.name}
Cargo: ${lead.decisionMaker?.role}

Genera el mensaje.`
                        }
                    ],
                    temperature: 0.6,
                    max_tokens: 150
                })
            });
            clearTimeout(timeoutId);

            if (!response.ok) {
                const err = await response.text();
                console.error('[MESSAGE] HTTP error:', response.status);
                throw new Error(`HTTP ${response.status}`);
            }

            const data = await response.json();
            const content = data.choices?.[0]?.message?.content || '';

            if (!content) {
                console.error('[MESSAGE] Empty response');
                throw new Error('Empty response');
            }

            const jsonMatch = content.match(/\{[\s\S]*\}/);

            if (jsonMatch) {
                const parsed = JSON.parse(jsonMatch[0]);
                console.log('[MESSAGE] âœ… Mensaje generado');
                return {
                    messageA: parsed.messageA || `Hola ${lead.decisionMaker?.name}, me gustarÃ­a hablar sobre automatizaciÃ³n.`
                };
            }
        } catch (e: any) {
            console.error('[MESSAGE] Error:', e.message);
        }

        // Fallback
        console.log('[MESSAGE] âš ï¸ Fallback message');
        return {
            messageA: `Hola ${lead.decisionMaker?.name || 'equipo'}, veo que gestionÃ¡is ${lead.companyName}. Tengo una soluciÃ³n para automatizar vuestros procesos.`
        };
    }

    private async callApifyActor(actorId: string, input: any, onLog: LogCallback): Promise<any[]> {
        // Use local proxy to avoid CORS
        const baseUrl = '/api/apify';
        const startUrl = `${baseUrl}/acts/${actorId}/runs?token=${this.apiKey}`;

        onLog(`[APIFY] ğŸ“¡ Lanzando actor ${actorId.substring(0, 8)}...`);
        console.log('[APIFY] POST a:', startUrl.substring(0, 100));

        // STAGE 1: Iniciar actor con timeout
        let startResponse: Response;
        try {
            const controller = new AbortController();
            const timeoutId = setTimeout(() => {
                controller.abort();
                console.error('[APIFY] TIMEOUT en POST /runs (10s)');
            }, 10000);

            startResponse = await fetch(startUrl, {
                method: 'POST',
                signal: controller.signal,
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(input)
            });
            clearTimeout(timeoutId);
        } catch (networkError: any) {
            console.error('[APIFY] Network error en POST /runs:', networkError.message);
            throw new Error(`Network error llamando Apify (Â¿proxy /api/apify funciona?): ${networkError.message}`);
        }

        if (!startResponse.ok) {
            const err = await startResponse.text();
            console.error(`[APIFY] HTTP ${startResponse.status}:`, err.substring(0, 300));
            onLog(`[APIFY] âŒ HTTP ${startResponse.status} al lanzar actor`);
            throw new Error(`Error actor ${actorId}: HTTP ${startResponse.status}`);
        }

        let startData: any;
        try {
            startData = await startResponse.json();
        } catch (e: any) {
            console.error('[APIFY] Error parsing JSON response:', e);
            throw new Error('Apify: Invalid JSON response');
        }

        const runId = startData.data?.id;
        const defaultDatasetId = startData.data?.defaultDatasetId;

        if (!runId || !defaultDatasetId) {
            console.error('[APIFY] Missing runId/defaultDatasetId:', { runId, defaultDatasetId });
            throw new Error('Apify: Response missing runId or defaultDatasetId');
        }

        onLog(`[APIFY] âœ… Actor iniciado (${runId.substring(0, 8)})`);
        console.log('[APIFY] Run started. Waiting for completion...');

        // STAGE 2: Poll status con timeout MAX 2 minutos
        let isFinished = false;
        let pollCount = 0;
        const MAX_POLLS = 24; // 24 * 5s = 120s

        while (!isFinished && this.isRunning && pollCount < MAX_POLLS) {
            await new Promise(r => setTimeout(r, 5000));
            pollCount++;

            try {
                const statusUrl = `${baseUrl}/acts/${actorId}/runs/${runId}?token=${this.apiKey}`;
                const statusRes = await fetch(statusUrl);

                if (!statusRes.ok) {
                    console.error(`[APIFY] Status fetch HTTP ${statusRes.status}`);
                    onLog(`[APIFY] âš ï¸ Error obtener status (HTTP ${statusRes.status})`);
                    continue;
                }

                const statusData = await statusRes.json();
                const status = statusData.data?.status;

                if (!status) {
                    console.error('[APIFY] Missing status in response:', statusData);
                    continue;
                }

                if (pollCount % 3 === 1) {
                    console.log(`[APIFY] Poll ${pollCount}/${MAX_POLLS}: ${status}`);
                    onLog(`[APIFY] Estado: ${status} (${pollCount * 5}s)`);
                }

                if (status === 'SUCCEEDED') {
                    isFinished = true;
                    console.log('[APIFY] âœ… SUCCEEDED after', pollCount * 5, 'seconds');
                } else if (status === 'FAILED' || status === 'ABORTED') {
                    console.error('[APIFY] Actor failed/aborted:', status);
                    throw new Error(`Actor ${status}`);
                }
            } catch (pollError: any) {
                console.error('[APIFY] Polling error:', pollError?.message);
                if (pollError.message?.includes('FAILED') || pollError.message?.includes('ABORTED')) {
                    throw pollError;
                }
            }
        }

        if (!isFinished) {
            console.error('[APIFY] TIMEOUT after', MAX_POLLS * 5, 'seconds');
            throw new Error(`Apify timeout: No completÃ³ en ${MAX_POLLS * 5}s`);
        }

        if (!this.isRunning) {
            console.log('[APIFY] Search stopped by user');
            return [];
        }

        // STAGE 3: Get dataset
        console.log('[APIFY] Fetching dataset:', defaultDatasetId);
        onLog(`[APIFY] ğŸ“¥ Descargando dataset...`);

        try {
            const itemsUrl = `${baseUrl}/datasets/${defaultDatasetId}/items?token=${this.apiKey}`;
            const itemsRes = await fetch(itemsUrl);

            if (!itemsRes.ok) {
                console.error(`[APIFY] Dataset HTTP ${itemsRes.status}`);
                throw new Error(`Dataset HTTP ${itemsRes.status}`);
            }

            const items = await itemsRes.json();

            if (!Array.isArray(items)) {
                console.error('[APIFY] Items not array:', typeof items, 'keys:', Object.keys(items || {}).slice(0, 5));
                throw new Error('Dataset response not array');
            }

            console.log('[APIFY] âœ… Got', items.length, 'items');
            onLog(`[APIFY] âœ… Dataset: ${items.length} items`);

            return items;
        } catch (datasetError: any) {
            console.error('[APIFY] Dataset error:', datasetError);
            throw datasetError;
        }
    }

    public async startSearch(
        config: SearchConfigState,
        onLog: LogCallback,
        onComplete: ResultCallback,
        userId?: string | null
    ) {
        this.isRunning = true;
        this.userId = userId || null;

        try {
            this.apiKey = import.meta.env.VITE_APIFY_API_TOKEN || '';

            onLog(`[INIT] ğŸ”‘ API Key: ${this.apiKey ? 'âœ… presente (' + this.apiKey.substring(0, 10) + '...)' : 'âŒ FALTA'}`);
            onLog(`[INIT] ğŸ§  OpenAI: âœ… API route /api/openai disponible`);
            onLog(`[INIT] ğŸ‘¤ UserId: ${this.userId || 'no autenticado'}`);
            onLog(`[INIT] ğŸ” Source: ${config.source} | Query: "${config.query}" | Max: ${config.maxResults}`);

            if (!this.apiKey) throw new Error("Falta VITE_APIFY_API_TOKEN en .env â€” configÃºrala en Vercel â†’ Settings â†’ Environment Variables");

            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // FASE 1: Pre-Flight - Descargar leads existentes del usuario
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            onLog(`[DEDUP] ğŸ” Iniciando verificaciÃ³n anti-duplicados...`);
            const { existingWebsites, existingCompanyNames, existingEmails, existingLinkedinUrls } =
                await deduplicationService.fetchExistingLeads(this.userId);
            onLog(`[DEDUP] âœ… Pre-flight: ${existingWebsites.size} dominios, ${existingCompanyNames.size} empresas en historial`);

            onLog(`[IA] ğŸ§  Interpretando: "${config.query}"...`);
            const interpreted = await this.interpretQuery(config.query, config.source);
            onLog(`[IA] âœ… Industria: ${interpreted.industry} | Roles: ${interpreted.targetRoles.join(', ')} | Zona: ${interpreted.location}`);

            if (config.source === 'linkedin') {
                onLog(`[LINKEDIN] ğŸš€ Iniciando bÃºsqueda LinkedIn...`);
                await this.searchLinkedIn(
                    config,
                    interpreted,
                    existingWebsites,
                    existingCompanyNames,
                    existingEmails,
                    existingLinkedinUrls,
                    onLog,
                    onComplete
                );
            } else {
                onLog(`[GMAIL] ğŸš€ Iniciando bÃºsqueda Gmail/Maps...`);
                await this.searchGmail(
                    config,
                    interpreted,
                    existingWebsites,
                    existingCompanyNames,
                    existingEmails,
                    existingLinkedinUrls,
                    onLog,
                    onComplete
                );
            }

        } catch (error: any) {
            console.error('[SearchService] FATAL ERROR:', error);
            onLog(`[ERROR] âŒ ${error.message}`);
            onLog(`[ERROR] ğŸ“‹ Stack: ${error.stack?.split('\n').slice(0, 3).join(' â†’ ') || 'no stack'}`);
            onComplete([]);
        } finally {
            this.isRunning = false;
        }
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // GMAIL SEARCH - SMART LOOP WITH PAGINATION
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    private async searchGmail(
        config: SearchConfigState,
        interpreted: { searchQuery: string; industry: string; targetRoles: string[]; location: string },
        existingWebsites: Set<string>,
        existingCompanyNames: Set<string>,
        existingEmails: Set<string>,
        existingLinkedinUrls: Set<string>,
        onLog: LogCallback,
        onComplete: ResultCallback
    ) {
        console.log('[GMAIL] ğŸš€ searchGmail iniciado');
        onLog(`[GMAIL] ğŸš€ Iniciando bÃºsqueda Gmail...`);

        let query = `${interpreted.searchQuery} ${interpreted.location}`;

        // Apply advanced filters to query if available
        if (config.advancedFilters) {
            query = this.buildQueryWithAdvancedFilters(query, config.advancedFilters);
            onLog(`[FILTERS] âœ… Filtros avanzados aplicados a la bÃºsqueda`);
        }

        onLog(`[GMAIL] ğŸ—ºï¸ Buscando: "${query}" (Smart Loop x4)...`);
        console.log('[GMAIL] Query:', query);

        const targetCount = config.maxResults;
        if (!targetCount || targetCount < 1) {
            onLog(`[ERROR] âŒ maxResults invÃ¡lido: ${targetCount}. Usando 1.`);
            onComplete([]);
            return;
        }
        const validLeads: Lead[] = [];
        let attempts = 0;
        const MAX_ATTEMPTS = 10;
        let totalScannedPreviously = 0;

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // SMART LOOP: Keep iterating until target reached or no more results
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        while (validLeads.length < targetCount && this.isRunning && attempts < MAX_ATTEMPTS) {
            attempts++;
            const needed = targetCount - validLeads.length;
            const fetchAmount = needed * 4; // Smart multiplier x4

            onLog(`[ATTEMPT ${attempts}] ğŸ”„ BÃºsqueda: ${fetchAmount} candidatos (faltantes: ${needed})...`);

            // STAGE 1: Google Maps scraping with pagination
            const totalMapsToScan = fetchAmount + totalScannedPreviously;

            const mapsResults = await this.callApifyActor(GOOGLE_MAPS_SCRAPER, {
                searchStringsArray: [query],
                maxCrawledPlacesPerSearch: Math.min(totalMapsToScan, 1000),
                language: 'es',
                includeWebsiteEmail: true,
                scrapeContacts: true,
                maxImages: 0,
                maxReviews: 0,
            }, onLog);

            onLog(`[DEBUG] ğŸ”§ Apify retornÃ³ ${mapsResults.length} items (esperÃ¡bamos ~${fetchAmount})...`);

            if (mapsResults.length === 0) {
                onLog(`[ATTEMPT ${attempts}] âš ï¸ No se encontraron mÃ¡s resultados en Maps.`);
                break; // No more results
            }

            onLog(`[DEBUG] ğŸ—ºï¸ Maps devolviÃ³ ${mapsResults.length} resultados...`);

            // Analyze what Apify returned
            const withWebsiteRaw = mapsResults.filter((r: any) => r.website).length;
            const withEmailRaw = mapsResults.filter((r: any) => r.email || r.emails?.length).length;
            onLog(`[DEBUG] ğŸ“Š ${withWebsiteRaw} con website, ${withEmailRaw} con email interno...`);

            // Update pagination tracker
            totalScannedPreviously += mapsResults.length;

            // Convert to leads
            let allLeads: Lead[] = mapsResults.map((item: any, index: number) => {
                // Extract website - try multiple field names
                let website = '';
                if (item.website) {
                    website = item.website.replace(/^https?:\/\//, '').replace(/\/$/, '').replace(/^www\./, '');
                } else if (item.websiteUrl) {
                    website = item.websiteUrl.replace(/^https?:\/\//, '').replace(/\/$/, '').replace(/^www\./, '');
                }

                // Extract email - try multiple field names
                let email = '';
                if (item.email) {
                    email = item.email;
                } else if (item.emails && Array.isArray(item.emails) && item.emails.length > 0) {
                    email = item.emails[0];
                }

                return {
                    id: String(item.placeId || `lead-${Date.now()}-${attempts}-${index}`),
                    source: 'gmail' as const,
                    companyName: item.title || item.name || 'Sin Nombre',
                    website: website,
                    location: item.address || item.fullAddress || '',
                    decisionMaker: {
                        name: '',
                        role: 'Propietario',
                        email: email,
                        phone: item.phone || (item.phones?.[0]) || '',
                        linkedin: '',
                        facebook: item.facebook || '',
                        instagram: item.instagram || '',
                    },
                    aiAnalysis: {
                        summary: `${item.categoryName || interpreted.industry} - ${item.reviewsCount || 0} reseÃ±as (${item.totalScore || 'N/A'}â­)`,
                        painPoints: [],
                        generatedIcebreaker: '',
                        fullMessage: '',
                        fullAnalysis: '',
                        psychologicalProfile: '',
                        businessMoment: '',
                        salesAngle: ''
                    },
                    status: 'scraped' as const
                };
            });

            // Filter deduplication from existing leads (catch new ones)
            const newCandidates = allLeads.filter(lead => {
                const cleanWeb = lead.website?.replace('www.', '').toLowerCase();
                const cleanName = lead.companyName.toLowerCase();

                // Check if already in validLeads from this session
                const isSessionDuplicate = validLeads.some(v =>
                    v.website === lead.website || v.companyName === lead.companyName
                );

                return !isSessionDuplicate;
            });

            const withWebsite = newCandidates.filter(l => l.website && l.website.length > 0).length;
            const withEmail = newCandidates.filter(l => l.decisionMaker?.email).length;
            onLog(`[ATTEMPT ${attempts}] ğŸ“Š Candidatos: ${newCandidates.length} total (${withWebsite} con website, ${withEmail} con email)`);

            if (newCandidates.length === 0) {
                onLog(`[ATTEMPT ${attempts}] âš ï¸ Todos los candidatos ya procesados.`);
                break;
            }

            onLog(`[ATTEMPT ${attempts}] âœ¨ ${newCandidates.length} candidatos Ãºnicos.`);
            allLeads = newCandidates;

            // STAGE 2: Aggressive Contact Enrichment
            const needEmail = allLeads.filter(l => !l.decisionMaker?.email && l.website);
            const alreadyHasEmail = allLeads.filter(l => l.decisionMaker?.email);

            onLog(`[ATTEMPT ${attempts}] â„¹ï¸ ${alreadyHasEmail.length} con email / ${needEmail.length} necesitan scraping...`);

            if (needEmail.length > 0 && this.isRunning) {
                const BATCH_SIZE = 10;
                const batches = Math.ceil(needEmail.length / BATCH_SIZE);

                for (let i = 0; i < batches && this.isRunning; i++) {
                    const start = i * BATCH_SIZE;
                    const end = start + BATCH_SIZE;
                    const batch = needEmail.slice(start, end);

                    try {
                        const contactResults = await this.callApifyActor(CONTACT_SCRAPER, {
                            startUrls: batch.map(l => ({ url: `https://${l.website}` })),
                            maxRequestsPerWebsite: 3,
                            sameDomainOnly: true,
                            maxCrawlingDepth: 1,
                        }, (msg) => { });

                        for (const contact of contactResults) {
                            const contactUrl = contact.url || '';
                            const match = batch.find(l => {
                                if (!l.website) return false;
                                return contactUrl.includes(l.website.replace('www.', ''));
                            });

                            if (match && contact.emails?.length) {
                                const validEmails = contact.emails.filter((e: string) =>
                                    !e.includes('sentry') && !e.includes('noreply') && !e.includes('wix') && e.includes('@')
                                );

                                if (validEmails.length > 0) {
                                    match.decisionMaker.email = validEmails[0];
                                    onLog(`[GMAIL] ğŸ“§ Email: ${validEmails[0]}`);
                                }
                            }
                        }
                    } catch (e: any) {
                        onLog(`[GMAIL] âš ï¸ Lote ${i + 1} fallÃ³: ${e.message}`);
                    }
                }
            }

            // Filter leads with email (but allow leads without email as fallback)
            const leadsWithEmail = allLeads.filter(l => l.decisionMaker?.email);
            const slotsRemaining = targetCount - validLeads.length;

            // Use leads with email, but if not enough, add leads without email
            let finalCandidates = leadsWithEmail.slice(0, slotsRemaining);

            if (finalCandidates.length < slotsRemaining && leadsWithEmail.length < allLeads.length) {
                const leadsWithoutEmail = allLeads.filter(l => !l.decisionMaker?.email);
                const slotsStillNeeded = slotsRemaining - finalCandidates.length;
                finalCandidates = finalCandidates.concat(leadsWithoutEmail.slice(0, slotsStillNeeded));
                onLog(`[ATTEMPT ${attempts}] â„¹ï¸ Agregando ${leadsWithoutEmail.slice(0, slotsStillNeeded).length} leads sin email como fallback...`);
            }

            if (finalCandidates.length === 0) {
                onLog(`[ATTEMPT ${attempts}] âš ï¸ No hay candidatos disponibles despuÃ©s del scraping.`);
                break; // Exit loop instead of continuing forever
            }

            onLog(`[ATTEMPT ${attempts}] ğŸ“Š ${leadsWithEmail.length} con email, ${finalCandidates.length - leadsWithEmail.length} sin email.`);

            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // DEDUPLICACIÃ“N GLOBAL: Filtrar contra el historial del usuario
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            onLog(`[DEDUP] ğŸ¯ Filtrando ${finalCandidates.length} candidatos contra historial global...`);
            const deduplicatedCandidates = deduplicationService.filterUniqueCandidates(
                finalCandidates,
                existingWebsites,
                existingCompanyNames,
                existingEmails,
                existingLinkedinUrls
            );

            if (deduplicatedCandidates.length < finalCandidates.length) {
                onLog(
                    `[DEDUP] âš ï¸ ${finalCandidates.length - deduplicatedCandidates.length} candidatos rechazados (ya en historial). ` +
                    `Quedaron ${deduplicatedCandidates.length} nuevos.`
                );
            }

            if (deduplicatedCandidates.length === 0) {
                onLog(`[ATTEMPT ${attempts}] â„¹ï¸ Todos los candidatos de este intento fueron rechazados por deduplicaciÃ³n.`);
                continue; // Try next attempt to find fresh leads
            }

            // Add successful leads to collection (only those that passed global dedup)
            const leadsToAdd = deduplicatedCandidates;

            for (const lead of leadsToAdd) {
                validLeads.push(lead);
                onLog(`[SUCCESS] âœ… Lead ${validLeads.length}/${targetCount}: ${lead.companyName}`);
            }
        } // End Smart Loop

        onLog(`[GMAIL] ğŸ“Š BÃºsqueda completada: ${validLeads.length}/${targetCount} en ${attempts} intentos...`);

        // STAGE 3: Quick AI analysis
        if (this.openaiKey && this.isRunning) {
            const leadsToAnalyze = validLeads.slice(0, targetCount);

            for (let i = 0; i < leadsToAnalyze.length && this.isRunning; i++) {
                const lead = leadsToAnalyze[i];
                lead.aiAnalysis.generatedIcebreaker = `Hola, he visto vuestra web ${lead.website}...`;
                lead.status = 'ready';

                if (leadsToAnalyze.length <= 20) {
                    try {
                        const research = await this.deepResearchLead(lead, (m) => { });
                        const analysis = await this.generateUltraAnalysis(lead, research);
                        lead.aiAnalysis.fullAnalysis = analysis.fullAnalysis;
                        lead.aiAnalysis.psychologicalProfile = analysis.psychologicalProfile;
                        lead.aiAnalysis.businessMoment = analysis.businessMoment;
                        lead.aiAnalysis.salesAngle = analysis.salesAngle;
                        lead.aiAnalysis.fullMessage = analysis.personalizedMessage;

                        // Generate Message A (Product-focused)
                        const messages = await this.generateOneMessage(lead);
                        lead.messageA = messages.messageA;
                    } catch (e) {
                        lead.aiAnalysis.fullMessage = `Contacto disponible en ${lead.website}`;
                        // Fallback message
                        lead.messageA = `Hola ${lead.decisionMaker?.name || 'equipo'}, quisiera hablar sobre automatizaciÃ³n.`;
                    }
                }
            }
        }

        onLog(`[GMAIL] ğŸ FINALIZADO: ${validLeads.length} leads listos`);
        onComplete(validLeads);
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // LINKEDIN SEARCH - SMART LOOP WITH PAGINATION
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    private async searchLinkedIn(
        config: SearchConfigState,
        interpreted: { searchQuery: string; industry: string; targetRoles: string[]; location: string },
        existingWebsites: Set<string>,
        existingCompanyNames: Set<string>,
        existingEmails: Set<string>,
        existingLinkedinUrls: Set<string>,
        onLog: LogCallback,
        onComplete: ResultCallback
    ) {
        console.log('[LINKEDIN] ğŸš€ searchLinkedIn iniciado');
        onLog(`[LINKEDIN] ğŸš€ Iniciando bÃºsqueda LinkedIn...`);

        const targetCount = config.maxResults;
        if (!targetCount || targetCount < 1) {
            onLog(`[ERROR] âŒ maxResults invÃ¡lido: ${targetCount}. Usando 1.`);
            onComplete([]);
            return;
        }

        const validLeads: Lead[] = [];
        let attempts = 0;
        const MAX_ATTEMPTS = 10;
        let currentPage = 1;

        onLog(`[LINKEDIN] ğŸ•µï¸â€â™‚ï¸ Target: ${targetCount} leads`);
        console.log('[LINKEDIN] Target count:', targetCount);

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // SMART LOOP: Paginate through results
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        while (validLeads.length < targetCount && this.isRunning && attempts < MAX_ATTEMPTS) {
            attempts++;
            const needed = targetCount - validLeads.length;
            const resultsToFetch = needed * 4; // x4 multiplier

            onLog(`[LINKEDIN-ATTEMPT ${attempts}] ğŸ”„ PÃ¡gina ${currentPage}: ${resultsToFetch} resultados...`);

            const roleTerms = interpreted.targetRoles.slice(0, 2).join(' OR ');
            const activeQuery = `site:linkedin.com/in ${roleTerms} "${interpreted.industry}" "${interpreted.location}"`;

            try {
                const searchResults = await this.callApifyActor(GOOGLE_SEARCH_SCRAPER, {
                    queries: activeQuery,
                    maxPagesPerQuery: currentPage, // Paginate
                    resultsPerPage: resultsToFetch,
                    languageCode: 'es',
                    countryCode: 'es',
                }, onLog);

                let allResults: any[] = [];
                for (const result of searchResults) {
                    if (result.organicResults) allResults = allResults.concat(result.organicResults);
                }

                if (allResults.length === 0) {
                    onLog(`[LINKEDIN-ATTEMPT ${attempts}] âš ï¸ No hay mÃ¡s resultados en pÃ¡gina ${currentPage}.`);
                    break;
                }

                const linkedInProfiles = allResults.filter((r: any) => r.url?.includes('linkedin.com/in/'));
                onLog(`[DEBUG] ğŸ‘¤ Perfiles encontrados: ${linkedInProfiles.length}`);

                if (linkedInProfiles.length === 0) {
                    onLog(`[LINKEDIN-ATTEMPT ${attempts}] âš ï¸ Sin perfiles en esta pÃ¡gina.`);
                    break;
                }

                // Transform raw profiles into provisional Leads
                const provisionalCandidates: Lead[] = [];
                for (let i = 0; i < linkedInProfiles.length; i++) {
                    const profile = linkedInProfiles[i];
                    const titleParts = (profile.title || '').split(' - ');
                    const name = titleParts[0]?.replace(' | LinkedIn', '').trim() || 'Usuario LinkedIn';
                    const role = this.extractRole(profile.title) || 'Decisor';
                    const company = this.extractCompany(profile.title) || 'Empresa Desconocida';

                    provisionalCandidates.push({
                        id: `linkedin-${Date.now()}-${i}`,
                        source: 'linkedin',
                        companyName: company,
                        website: '',
                        location: interpreted.location,
                        decisionMaker: {
                            name,
                            role,
                            email: '',
                            phone: '',
                            linkedin: profile.url
                        },
                        aiAnalysis: {
                            summary: '',
                            fullAnalysis: '',
                            psychologicalProfile: '',
                            businessMoment: '',
                            salesAngle: '',
                            fullMessage: '',
                            generatedIcebreaker: '',
                            painPoints: []
                        },
                        isNPLPotential: false,
                        status: 'scraped'
                    });
                }

                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                // DEDUPLICATION: Filter against current session & global history BEFORE analysis
                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                const sessionUnique = provisionalCandidates.filter(candidate =>
                    !validLeads.some(dl => dl.companyName === candidate.companyName || dl.decisionMaker?.linkedin === candidate.decisionMaker?.linkedin)
                );

                let globalUnique: Lead[] = [];
                if (sessionUnique.length > 0) {
                    onLog(`[DEDUP] ğŸ¯ Filtrando ${sessionUnique.length} candidatos LinkedIn contra historial global...`);
                    globalUnique = deduplicationService.filterUniqueCandidates(
                        sessionUnique,
                        existingWebsites,
                        existingCompanyNames,
                        existingEmails,
                        existingLinkedinUrls
                    );

                    if (globalUnique.length < sessionUnique.length) {
                        onLog(
                            `[DEDUP] âš ï¸ ${sessionUnique.length - globalUnique.length} duplicados descartados. ` +
                            `Quedan ${globalUnique.length} nuevos por procesar.`
                        );
                    }
                }

                if (globalUnique.length === 0) {
                    onLog(`[LINKEDIN-ATTEMPT ${attempts}] â„¹ï¸ Todos los candidatos de esta pÃ¡gina ya existen en historial.`);
                    currentPage++;
                    continue;
                }

                // Slice the results exactly to what we need
                const remainingSlots = targetCount - validLeads.length;
                const candidatesToProcess = globalUnique.slice(0, remainingSlots);

                onLog(`[INFO] Procesando ${candidatesToProcess.length} leads Ãºnicos (saltando el resto para respetar target: ${targetCount}).`);

                const POSTS_SCRAPER = 'LQQIXN9Othf8f7R5n';

                // Process AI only for the needed unique profiles
                for (let i = 0; i < candidatesToProcess.length && this.isRunning; i++) {
                    if (validLeads.length >= targetCount) break;

                    const candidate = candidatesToProcess[i];
                    onLog(`[RESEARCH] ğŸ§  Analizando: ${candidate.decisionMaker?.name}...`);

                    let recentPostsText = "";
                    try {
                        const postsData = await this.callApifyActor(POSTS_SCRAPER, {
                            username: candidate.decisionMaker?.linkedin,
                            limit: 3
                        }, () => { });

                        if (postsData && postsData.length > 0) {
                            recentPostsText = postsData.map((p: any) => `${p.text?.substring(0, 150)}...`).join('\n');
                        }
                    } catch (e) {
                        // Silent - posts are optional
                    }

                    const researchDossier = `PERFIL: ${candidate.decisionMaker?.name}\nHeadline: ${candidate.decisionMaker?.role} en ${candidate.companyName}\nReciente: ${recentPostsText || "N/A"}`;

                    try {
                        const analysis = await this.generateUltraAnalysis({
                            companyName: candidate.companyName,
                            decisionMaker: { name: candidate.decisionMaker?.name, role: candidate.decisionMaker?.role, linkedin: candidate.decisionMaker?.linkedin }
                        } as Lead, researchDossier);

                        // Generate Message A (Product-focused)
                        const messages = await this.generateOneMessage({
                            companyName: candidate.companyName,
                            decisionMaker: { name: candidate.decisionMaker?.name, role: candidate.decisionMaker?.role, linkedin: candidate.decisionMaker?.linkedin }
                        } as Lead);

                        candidate.aiAnalysis = {
                            summary: `PsicologÃ­a: ${analysis.bottleneck}`,
                            fullAnalysis: analysis.fullAnalysis,
                            psychologicalProfile: analysis.psychologicalProfile,
                            businessMoment: analysis.businessMoment,
                            salesAngle: analysis.salesAngle,
                            fullMessage: analysis.personalizedMessage,
                            generatedIcebreaker: analysis.bottleneck,
                            painPoints: []
                        };
                        candidate.messageA = messages.messageA;
                        candidate.status = 'ready';

                        validLeads.push(candidate);
                        onLog(`[SUCCESS] âœ… Lead ${validLeads.length}/${targetCount}: ${candidate.companyName}`);

                    } catch (e) {
                        onLog(`[RESEARCH] âš ï¸ AnÃ¡lisis fallido para ${candidate.decisionMaker?.name}`);
                    }
                }

                currentPage++;

            } catch (error: any) {
                onLog(`[LINKEDIN-ATTEMPT ${attempts}] âŒ Error: ${error.message}`);
                break;
            }
        } // End Smart Loop

        onLog(`[LINKEDIN] ğŸ BÃºsqueda completada: ${validLeads.length}/${targetCount} en ${attempts} intentos`);
        onComplete(validLeads);
    }

    private extractCompany(text: string): string {
        // Heuristic: "CEO en [Empresa]" or "CEO at [Company]"
        const atMatch = text.match(/\b(en|at|@)\s+([^|\-.,]+)/i);
        if (atMatch && atMatch[2]) return atMatch[2].trim();
        return '';
    }

    private extractRole(text: string): string {
        const lower = text.toLowerCase();
        if (lower.includes('ceo')) return 'CEO';
        if (lower.includes('founder') || lower.includes('fundador')) return 'Fundador';
        if (lower.includes('owner') || lower.includes('propietario')) return 'Propietario';
        if (lower.includes('director')) return 'Director';
        return '';
    }
}

export const searchService = new SearchService();
